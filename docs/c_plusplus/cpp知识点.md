## 全都是知识点

### 与C的区别

1. 空参数函数
2. struct enum   定义变量可以不加关键字

``` c++

struct student{

   int age；

}；

student stu；

```

### 命名空间

1. 头文件尽量不要用`using namespace xx`， 名称污染
2. 无名命名空间

### 引用

定义引用类型的变量时必须制定引用目标。

1. 引用和指针
2. 常引用

使用`const`修饰，则不可以通过引用修改目标的值，而可以修改引用的目标

3. 引用就是别名

### 函数

#### 缺省参数

- 靠右原则

  缺省参数放到形参表的最右边

- 优先使用实参
- 函数的缺省参数一般放在头文件定义。

#### 哑元函数

只指定类型，没有形参名

#### 常函数

`void func(arg) const {}`

`const`修饰了`this`指针，`this`指向的内容不可修改。若要修改必须加`mutable`关键字

#### 友元函数

`friend`修饰。

1. 友元函数在类内部声明，外部实现。函数名前面不加类名
2. 友元函数不属于类，没有`this`指针
3. 友元函数可以访问类中的所有成员，打破了成员访问控制属性
4. 如果访问静态成员，友元函数不需要类名
5. 友元函数的调用，不需要加类名

#### 常对象

使用`const` 修饰，常对象只能访问对象中的常函数。

### 内存

new/delete 是运算符。

使用`new`可以同时进行初始化

```c++
new int(10);
new int[10]{0,1,2,3,4,5,6,7,8,9};
```



### 类

面向对象三大特征：封装，继承和多态

#### this指针

1. 区分作用域
2. 返回自身引用
3. 在类内部销毁对象

#### 构造函数

与类名字相同，无返回值。在实例化对象时候被调用。

1. ##### 构造函数初始化表

`类名（形参表）: 初始化表{}`

必须使用初始化表的几种情况：

- 包含引用类型成员变量
- 包含`const`修饰的成员

2.  ##### 深拷贝

- 复制构造函数

```c++
//声明的语法
//类名（const 类名 &）

class MyString
{
    MyString(const MyString& copySource); // copy constructor
};
```

- 复制赋值函数

```c++
//类名 & operator(const 类名 &that)

ClassType& operator= (const ClassType& copySource)
{
    if(this != &copySource) // protection against copy into self
    {
    // copy assignment operator implementation
    }
    return *this;
}
```



#### 静态成员

使用`static`修饰的成员

##### 静态成员变量

1. 静态成员变量变量在类的内部声明，初始化必须放在外部。不可以在构造函数中初始化。
2. 静态成员变量不属于类
3. 静态成员变量全局变量，存放在全局区
4. 静态成员变量的访问可以通过类名方式，`类名::静态成员`。也可以通过对象名访问

##### 静态成员函数

1. 静态成员函数没有`this`指针，所以不能是常函数。

2. 静态成员函数不能范文普通成员变量

   


### 继承
